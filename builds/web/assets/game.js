/* Generated by Opal 0.7.0.beta1 */
Opal.modules["quadtree"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$[]', '$clear', '$each', '$to_proc', '$node_for', '$nil?', '$<<', '$empty?', '$count', '$split', '$things_near', '$stroke_color=', '$stroke_width=', '$stroke_rectangle', '$draw', '$private', '$new', '$delete', '$bottom', '$top', '$right', '$left']);
  return (function($base, $super) {
    function $Quadtree(){};
    var self = $Quadtree = $klass($base, $super, 'Quadtree', $Quadtree);

    var def = self.$$proto, $scope = self.$$scope;

    def.things = def.nodes = def.level = def.x = def.y = def.width = def.height = nil;
    $opal.cdecl($scope, 'MAX_THINGS', 5);

    $opal.cdecl($scope, 'MAX_LEVELS', 5);

    $opal.cdecl($scope, 'COLOR', $scope.get('Color')['$[]']("#f33"));

    def.$initialize = function(x, y, width, height, level) {
      var self = this;

      if (level == null) {
        level = 0
      }
      self.x = x;
      self.y = y;
      self.width = width;
      self.height = height;
      self.level = level;
      self.things = [];
      return self.nodes = [];
    };

    def.$clear = function() {
      var $a, $b, self = this;

      self.things.$clear();
      return ($a = ($b = self.nodes).$each, $a.$$p = "clear".$to_proc(), $a).call($b);
    };

    def['$<<'] = function(thing) {
      var $a, $b, $c, self = this, node = nil;

      node = self.$node_for(thing);
      if ((($a = node['$nil?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        } else {
        node['$<<'](thing);
        return nil;
      };
      self.things['$<<'](thing);
      if ((($a = ($b = ($c = self.nodes['$empty?'](), $c !== false && $c !== nil ?$rb_gt(self.things.$count(), $scope.get('MAX_THINGS')) : $c), $b !== false && $b !== nil ?$rb_lt(self.level, $scope.get('MAX_LEVELS')) : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
        return self.$split()
        } else {
        return nil
      };
    };

    def['$things='] = function(list) {
      var $a, $b, TMP_1, self = this;

      self.$clear();
      return ($a = ($b = list).$each, $a.$$p = (TMP_1 = function(t){var self = TMP_1.$$s || this;
if (t == null) t = nil;
      return self['$<<'](t)}, TMP_1.$$s = self, TMP_1), $a).call($b);
    };

    def.$things_near = function(thing, list) {
      var $a, self = this, node = nil;

      if (list == null) {
        list = []
      }
      node = self.$node_for(thing);
      if ((($a = node['$nil?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        } else {
        list = node.$things_near(thing, list)
      };
      return $rb_plus(list, self.things);
    };

    def.$draw = function(d) {
      var $a, $b, TMP_2, self = this;

      (($a = [$scope.get('COLOR')]), $b = d, $b['$stroke_color='].apply($b, $a), $a[$a.length-1]);
      (($a = [1]), $b = d, $b['$stroke_width='].apply($b, $a), $a[$a.length-1]);
      d.$stroke_rectangle(self.x, self.y, self.width, self.height);
      return ($a = ($b = self.nodes).$each, $a.$$p = (TMP_2 = function(n){var self = TMP_2.$$s || this;
if (n == null) n = nil;
      return n.$draw(d)}, TMP_2.$$s = self, TMP_2), $a).call($b);
    };

    self.$private();

    def.$split = function() {
      var $a, $b, TMP_3, self = this, half_width = nil, half_height = nil, next_level = nil;

      half_width = $rb_divide(self.width, 2);
      half_height = $rb_divide(self.height, 2);
      next_level = $rb_plus(self.level, 1);
      self.nodes = [$scope.get('Quadtree').$new($rb_plus(self.x, half_width), self.y, half_width, half_height, next_level), $scope.get('Quadtree').$new(self.x, self.y, half_width, half_height, next_level), $scope.get('Quadtree').$new(self.x, $rb_plus(self.y, half_height), half_width, half_height, next_level), $scope.get('Quadtree').$new($rb_plus(self.x, half_width), $rb_plus(self.y, half_height), half_width, half_height, next_level)];
      return ($a = ($b = self.things).$each, $a.$$p = (TMP_3 = function(thing){var self = TMP_3.$$s || this, $a, node = nil;
        if (self.things == null) self.things = nil;
if (thing == null) thing = nil;
      node = self.$node_for(thing);
        if ((($a = node['$nil?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
          return nil
          } else {
          return node['$<<'](self.things.$delete(thing))
        };}, TMP_3.$$s = self, TMP_3), $a).call($b);
    };

    return (def.$node_for = function(thing) {
      var $a, $b, self = this, middle_x = nil, middle_y = nil, fits_top = nil, fits_bottom = nil;

      if ((($a = ((($b = self.nodes['$empty?']()) !== false && $b !== nil) ? $b : thing['$nil?']())) !== nil && (!$a.$$is_boolean || $a == true))) {
        return nil};
      middle_x = $rb_plus(self.x, $rb_divide(self.width, 2));
      middle_y = $rb_plus(self.y, $rb_divide(self.height, 2));
      fits_top = $rb_lt(thing.$bottom(), middle_y);
      fits_bottom = $rb_gt(thing.$top(), middle_y);
      if ($rb_lt(thing.$right(), middle_x)) {
        if (fits_top !== false && fits_top !== nil) {
          return self.nodes['$[]'](1)
        } else if (fits_bottom !== false && fits_bottom !== nil) {
          return self.nodes['$[]'](2)
          } else {
          return nil
        }
      } else if ($rb_gt(thing.$left(), middle_x)) {
        if (fits_top !== false && fits_top !== nil) {
          return self.nodes['$[]'](0)
        } else if (fits_bottom !== false && fits_bottom !== nil) {
          return self.nodes['$[]'](3)
          } else {
          return nil
        }
        } else {
        return nil
      };
    }, nil) && 'node_for';
  })(self, null)
};

/* Generated by Opal 0.7.0.beta1 */
Opal.modules["scene"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$require', '$[]', '$attr_accessor', '$attr_reader', '$times', '$add_box', '$pressing?', '$keyboard', '$remove_box', '$collide_boxes', '$stroke_color=', '$stroke_width=', '$stroke_rectangle', '$each_with_index', '$nil?', '$in_collision', '$==', '$colliding?', '$in_collision=', '$!', '$filled', '$things', '$[]=', '$compact!', '$size', '$<<', '$new', '$rand', '$shift']);
  self.$require("quadtree");
  return (function($base, $super) {
    function $Scene(){};
    var self = $Scene = $klass($base, $super, 'Scene', $Scene);

    var def = self.$$proto, $scope = self.$$scope;

    def.width = def.height = def.things = def.box_count = nil;
    $opal.cdecl($scope, 'BORDER_COLOR', $scope.get('Color')['$[]'](10, 10, 10));

    self.$attr_accessor("things", "width", "height");

    self.$attr_reader("box_count");

    def.$initialize = function() {
      var $a, $b, TMP_1, self = this;

      self.box_repro_chance = 0.2;
      self.width = 512;
      self.height = 512;
      self.things = [];
      self.box_count = 0;
      return ($a = ($b = (100)).$times, $a.$$p = (TMP_1 = function(){var self = TMP_1.$$s || this;

      return self.$add_box()}, TMP_1.$$s = self, TMP_1), $a).call($b);
    };

    def.$update = function(game, elapsed) {
      var $a, self = this;

      if ((($a = game.$keyboard()['$pressing?']("equals")) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.$add_box()
      } else if ((($a = game.$keyboard()['$pressing?']("minus")) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.$remove_box()};
      
      for (var i = 0; i < self.things.length; i++) {
        self.things[i].$update(game, self.things, elapsed);
      }
    
      return self.$collide_boxes();
    };

    def.$draw = function(display) {
      var $a, $b, self = this;

      
      for (var i = 0; i < self.things.length; i++) {
        self.things[i].$draw(display);
      }
    
      (($a = [$scope.get('BORDER_COLOR')]), $b = display, $b['$stroke_color='].apply($b, $a), $a[$a.length-1]);
      (($a = [3]), $b = display, $b['$stroke_width='].apply($b, $a), $a[$a.length-1]);
      return display.$stroke_rectangle(0, 0, self.width, self.height);
    };

    def.$collide_boxes = function() {
      var $a, $b, TMP_2, self = this;

      ($a = ($b = self.things).$each_with_index, $a.$$p = (TMP_2 = function(thing, i){var self = TMP_2.$$s || this, $a, $b, TMP_3, $c, b1_ind = nil, b2_ind = nil, collided_tmp = nil;
        if (self.things == null) self.things = nil;
if (thing == null) thing = nil;if (i == null) i = nil;
      b1_ind = i;
        b2_ind = nil;
        if ((($a = thing['$nil?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
          return nil;};
        collided_tmp = thing.$in_collision();
        ($a = ($b = self.things).$each_with_index, $a.$$p = (TMP_3 = function(thing2, i2){var self = TMP_3.$$s || this, $a, $b;
if (thing2 == null) thing2 = nil;if (i2 == null) i2 = nil;
        if ((($a = ((($b = thing['$=='](thing2)) !== false && $b !== nil) ? $b : thing2['$nil?']())) !== nil && (!$a.$$is_boolean || $a == true))) {
            return nil;};
          if ((($a = thing['$colliding?'](thing2)) !== nil && (!$a.$$is_boolean || $a == true))) {
            (($a = [true]), $b = thing, $b['$in_collision='].apply($b, $a), $a[$a.length-1]);
            b2_ind = i2;
            return ($breaker.$v = nil, $breaker);};
          return (($a = [false]), $b = thing, $b['$in_collision='].apply($b, $a), $a[$a.length-1]);}, TMP_3.$$s = self, TMP_3), $a).call($b);
        if ((($a = ($c = collided_tmp['$!'](), $c !== false && $c !== nil ?thing.$in_collision() : $c)) !== nil && (!$a.$$is_boolean || $a == true))) {
          if ((($a = ($c = self.$things()['$[]'](b1_ind).$filled(), $c !== false && $c !== nil ?self.$things()['$[]'](b2_ind).$filled() : $c)) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.$add_box()
          } else if ((($a = ($c = self.$things()['$[]'](b1_ind).$filled()['$!'](), $c !== false && $c !== nil ?self.$things()['$[]'](b2_ind).$filled()['$!']() : $c)) !== nil && (!$a.$$is_boolean || $a == true))) {
            self.things['$[]='](b1_ind, nil);
            return self.things['$[]='](b2_ind, nil);
          } else if ((($a = self.things['$[]'](b1_ind).$filled()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.things['$[]='](b1_ind, nil)
          } else if ((($a = self.things['$[]'](b2_ind).$filled()) !== nil && (!$a.$$is_boolean || $a == true))) {
            return self.things['$[]='](b2_ind, nil)
            } else {
            return nil
          }
        } else if ((($a = (($c = collided_tmp !== false && collided_tmp !== nil) ? thing.$in_collision()['$!']() : $c)) !== nil && (!$a.$$is_boolean || $a == true))) {
          return nil
          } else {
          return nil
        };}, TMP_2.$$s = self, TMP_2), $a).call($b);
      self.things['$compact!']();
      return self.box_count = self.things.$size();
    };

    def.$add_box = function() {
      var self = this;

      self.$things()['$<<']($scope.get('Box').$new($rb_times(self.width, self.$rand()), $rb_times(self.height, self.$rand())));
      return self.box_count = $rb_plus(self.box_count, 1);
    };

    return (def.$remove_box = function() {
      var $a, self = this;

      if ((($a = self.$things().$shift()['$nil?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        return nil
        } else {
        return self.box_count = $rb_minus(self.box_count, 1)
      };
    }, nil) && 'remove_box';
  })(self, null);
};

/* Generated by Opal 0.7.0.beta1 */
Opal.modules["box"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$[]', '$attr_accessor', '$attr_reader', '$rand', '$zero?', '$round', '$y', '$height', '$scene', '$x', '$width', '$stroke_color=', '$stroke_width=', '$stroke_rectangle', '$fill_color=', '$fill_rectangle', '$left', '$right', '$top', '$bottom']);
  return (function($base, $super) {
    function $Box(){};
    var self = $Box = $klass($base, $super, 'Box', $Box);

    var def = self.$$proto, $scope = self.$$scope;

    def.velocity_x = def.velocity_y = def.x = def.y = def.width = def.height = def.filled = def.z = def.depth = nil;
    $opal.cdecl($scope, 'COLOR', $scope.get('Color')['$[]'](201, 94, 18));

    self.$attr_accessor("x", "y", "width", "height", "velocity", "in_collision");

    self.$attr_reader("filled");

    def.$initialize = function(x, y) {
      var $a, self = this;

      if (x == null) {
        x = 0
      }
      if (y == null) {
        y = 0
      }
      self.x = x;
      self.y = y;
      self.in_collision = false;
      self.width = 20;
      self.height = 20;
      self.filled = $rb_ge(self.$rand(), 0.5);
      self.velocity_x = 48;
      self.velocity_y = 48;
      if ((($a = self.$rand().$round()['$zero?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.velocity_x = $rb_times(self.velocity_x, -1)};
      if ((($a = self.$rand().$round()['$zero?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        return self.velocity_y = $rb_times(self.velocity_y, -1)
        } else {
        return nil
      };
    };

    def.$update = function(game, things, elapsed) {
      var self = this;

      self.x = $rb_plus(self.x, $rb_times(self.velocity_x, elapsed));
      self.y = $rb_plus(self.y, $rb_times(self.velocity_y, elapsed));
      if ($rb_lt(self.$y(), 0)) {
        self.y = 0;
        self.velocity_y = $rb_times(self.velocity_y, -1);
      } else if ($rb_gt($rb_plus(self.$y(), self.$height()), game.$scene().$height())) {
        self.y = $rb_minus(game.$scene().$height(), self.$height());
        self.velocity_y = $rb_times(self.velocity_y, -1);};
      if ($rb_lt(self.$x(), 0)) {
        self.x = 0;
        return self.velocity_x = $rb_times(self.velocity_x, -1);
      } else if ($rb_gt($rb_plus(self.$x(), self.$width()), game.$scene().$width())) {
        self.x = $rb_minus(game.$scene().$width(), self.$width());
        return self.velocity_x = $rb_times(self.velocity_x, -1);
        } else {
        return nil
      };
    };

    def.$draw = function(d) {
      var $a, $b, self = this;

      (($a = [$scope.get('COLOR')]), $b = d, $b['$stroke_color='].apply($b, $a), $a[$a.length-1]);
      (($a = [2]), $b = d, $b['$stroke_width='].apply($b, $a), $a[$a.length-1]);
      d.$stroke_rectangle(self.x, self.y, self.width, self.height);
      if ((($a = self.filled) !== nil && (!$a.$$is_boolean || $a == true))) {
        (($a = [$scope.get('COLOR')]), $b = d, $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
        d.$fill_rectangle(self.x, self.y, self.width, self.height);
        return self.collided = false;
        } else {
        return nil
      };
    };

    def.$top = function() {
      var self = this;

      return self.y;
    };

    def.$bottom = function() {
      var self = this;

      return $rb_plus(self.y, self.height);
    };

    def.$left = function() {
      var self = this;

      return self.x;
    };

    def.$right = function() {
      var self = this;

      return $rb_plus(self.x, self.width);
    };

    def.$front = function() {
      var self = this;

      return self.z;
    };

    def.$back = function() {
      var self = this;

      return $rb_plus(self.z, self.depth);
    };

    def.$center = function() {
      var self = this;

      return [$rb_plus(self.x, $rb_divide(self.width, 2)), $rb_plus(self.y, $rb_divide(self.height, 2))];
    };

    return (def['$colliding?'] = function(thing) {
      var $a, $b, $c, self = this;

      return self.in_collision = ($a = ($b = (($c = $rb_lt(self.$left(), thing.$right())) ? $rb_gt(self.$right(), thing.$left()) : $c), $b !== false && $b !== nil ?$rb_lt(self.$top(), thing.$bottom()) : $b), $a !== false && $a !== nil ?$rb_gt(self.$bottom(), thing.$top()) : $a);
    }, nil) && 'colliding?';
  })(self, null)
};

/* Generated by Opal 0.7.0.beta1 */
(function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$require', '$[]', '$attr_accessor', '$new', '$update', '$fill_color=', '$display', '$clear', '$push', '$height', '$translate', '$draw', '$pop', '$width', '$text_size', '$fill_text', '$ticks_per_second', '$ticker', '$box_count']);
  self.$require("scene");
  self.$require("box");
  return (function($base, $super) {
    function $CollisionsDemo(){};
    var self = $CollisionsDemo = $klass($base, $super, 'CollisionsDemo', $CollisionsDemo);

    var def = self.$$proto, $scope = self.$$scope;

    def.scene = nil;
    $opal.cdecl($scope, 'BG_COLOR', $scope.get('Color')['$[]'](211, 169, 96));

    $opal.cdecl($scope, 'TEXT_COLOR', $scope.get('Color')['$[]'](10, 10, 10));

    $opal.cdecl($scope, 'LIGHT_TEXT_COLOR', $scope.get('Color')['$[]'](90, 90, 90));

    self.$attr_accessor("scene");

    def.$setup = function() {
      var self = this;

      return self.scene = $scope.get('Scene').$new();
    };

    return (def.$update = function(elapsed) {
      var $a, $b, self = this, offset = nil, text_x = nil, text_y = nil, line_height = nil;

      self.scene.$update(self, elapsed);
      (($a = [$scope.get('BG_COLOR')]), $b = self.$display(), $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      self.$display().$clear();
      self.$display().$push();
      offset = $rb_divide(($rb_minus(self.$display().$height(), self.scene.$height())), 2);
      self.$display().$translate(offset, offset);
      self.scene.$draw(self.$display());
      self.$display().$pop();
      text_x = $rb_plus(self.scene.$width(), $rb_times(offset, 2));
      text_y = $rb_plus(offset, self.$display().$text_size());
      line_height = self.$display().$text_size();
      (($a = [$scope.get('TEXT_COLOR')]), $b = self.$display(), $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      self.$display().$fill_text("fps: " + (self.$ticker().$ticks_per_second()), text_x, text_y);
      self.$display().$fill_text("boxes: " + (self.scene.$box_count()), text_x, $rb_plus(text_y, $rb_times(line_height, 2)));
      (($a = [$scope.get('LIGHT_TEXT_COLOR')]), $b = self.$display(), $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      self.$display().$fill_text("+ add, - remove", $rb_plus(text_x, 120), $rb_plus(text_y, $rb_times(line_height, 2)));
      return (($a = [$scope.get('TEXT_COLOR')]), $b = self.$display(), $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
    }, nil) && 'update';
  })(self, $scope.get('Game'));
})(Opal);

//# sourceMappingURL=game.map
;
